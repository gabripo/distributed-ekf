clear all
close all
clc

%% Simulation set-up
% Sampling time
MdlInit.Ts = 0.05;

% Length of simulation
MdlInit.T = 10;

%% Vehicles set-up
% Initial conditions of vehicles
Vehicles.A.q0 = [0; 1; pi/4];
Vehicles.B.q0 = [1; 1; pi/2];

% Vehicles wheel radius
Vehicles.A.R = 0.15;
Vehicles.B.R = 0.15;

% Vehicles inter-axle
Vehicles.A.L = 0.56;
Vehicles.B.L = 0.56;

% Unycicle simulations
[Vehicles.A.q, Vehicles.A.t, Vehicles.A.u] = UnicycleKinematicMatlab(MdlInit, Vehicles.A);
[Vehicles.B.q, Vehicles.B.t, Vehicles.B.u] = UnicycleKinematicMatlab(MdlInit, Vehicles.B);

%% Noises - equal for all the vehicles

% Encoder quantization
Noise.Enc.Quanta = 2*pi/2600;

% Encoder noise
Noise.Enc.mu = 0;
Noise.Enc.sigma = 2*Noise.Enc.Quanta/3;

% GPS noise - only 2D coordinates (added orientation to test)
Noise.GPS.mu = zeros(3,1);
Noise.GPS.MaxPosErr = 1;    % [m]
Noise.GPS.R = diag([ (Noise.GPS.MaxPosErr/3)^2, (Noise.GPS.MaxPosErr/3)^2, (pi/6/3)^2]);

% Relative positions noise (for a couple of robots)
Noise.Rel.mu = zeros(3,1);
Noise.Rel.MaxBearErr = pi/6;    % [rad]
Noise.Rel.MaxDistErr = 1;       % [m]
Noise.Rel.MaxOriErr = pi/6;     % [rad]
Noise.Rel.R = diag([ (Noise.Rel.MaxBearErr/3)^2, (Noise.Rel.MaxDistErr/3)^2, (Noise.Rel.MaxOriErr/3)^2 ]);

%% Sensors simulation

% Encoders
[Sensor.A.Enc.Right, Sensor.A.Enc.Left] = EncoderSim(Vehicles.A.u, Vehicles.A.t, Vehicles.A);
[Sensor.B.Enc.Right, Sensor.B.Enc.Left] = EncoderSim(Vehicles.B.u, Vehicles.B.t, Vehicles.B);

% Noisy encoders
[Sensor.A.Enc.NoisyRight, Sensor.A.Enc.NoisyLeft] = EncoderNoise(Sensor.A, Noise);
[Sensor.B.Enc.NoisyRight, Sensor.B.Enc.NoisyLeft] = EncoderNoise(Sensor.B, Noise);

% GPS
[Sensor.A.GPS.q_m] = GPSsym(Vehicles.A.q);
[Sensor.B.GPS.q_m] = GPSsym(Vehicles.B.q);

[Sensor.A.GPS.Noisyq_m] = GPSNoise(Vehicles.A.q, Noise);
[Sensor.B.GPS.Noisyq_m] = GPSNoise(Vehicles.B.q, Noise);

% Relative measurements
[Sensor.AB.q_rel] = RelSym(Vehicles.A.q, Vehicles.B.q);

[Sensor.AB.Noisyq_rel] = RelSymNoise(Sensor.AB.q_rel, Noise);

%% EKF Initialization
% States initialization - 6 dofs on the plane, 3 for each vehicle
EKF.A.q_est = zeros(3,1);
EKF.B.q_est = zeros(3,1);

% Initial covariance matrix of the states
EKF.A.P = 1e2*eye(3);
EKF.B.P = 1e2*eye(3);
EKF.AB.P = 1e2*eye(3);

% Covariance matrix of the model variables: 2 encoders per vehicle +
% relative positions between vehicles
EKF.A.Q = diag([Noise.Enc.sigma^2, Noise.Enc.sigma^2]);
EKF.B.Q = diag([Noise.Enc.sigma^2, Noise.Enc.sigma^2]);

% Covariance matrix of the measurements
EKF.A.R = Noise.GPS.R;
EKF.B.R = Noise.GPS.R;

% Number of samples
EKF.NumS = length(Vehicles.A.t);
EKF.A.q_store = zeros(3,EKF.NumS);
EKF.B.q_store = zeros(3,EKF.NumS);
EKF.A.q_store(:,1) = EKF.A.q_est;
EKF.B.q_store(:,1) = EKF.B.q_est;

%% EKF Algorithm

for i=2:EKF.NumS
    
   %% Encoder data Integration    
    % Odometry measurement
    EKF.A.DeltaEnc = [Sensor.A.Enc.NoisyRight(i) - Sensor.A.Enc.NoisyRight(i-1);
        Sensor.A.Enc.NoisyLeft(i) - Sensor.A.Enc.NoisyLeft(i-1)];
    EKF.B.DeltaEnc = [Sensor.B.Enc.NoisyRight(i) - Sensor.B.Enc.NoisyRight(i-1);
        Sensor.B.Enc.NoisyLeft(i) - Sensor.B.Enc.NoisyLeft(i-1)];
    
    % Jacobian matrices
    Fx_ik = [1 0 -sin(EKF.A.q_est(3))*Vehicles.A.R/2*(EKF.A.DeltaEnc(1) + EKF.A.DeltaEnc(2));
             0 1 cos(EKF.A.q_est(3))*Vehicles.A.R/2*(EKF.A.DeltaEnc(1) + EKF.A.DeltaEnc(2));
             0 0 1];
    Fu_ik = [cos(EKF.A.q_est(3))*Vehicles.A.R/2, cos(EKF.A.q_est(3))*Vehicles.A.R/2;
             sin(EKF.A.q_est(3))*Vehicles.A.R/2, sin(EKF.A.q_est(3))*Vehicles.A.R/2;
             Vehicles.A.R/Vehicles.A.L, -Vehicles.A.R/Vehicles.A.L];
    Fx_jk = [1 0 -sin(EKF.B.q_est(3))*Vehicles.B.R/2*(EKF.B.DeltaEnc(1) + EKF.B.DeltaEnc(2));
             0 1 cos(EKF.B.q_est(3))*Vehicles.B.R/2*(EKF.B.DeltaEnc(1) + EKF.B.DeltaEnc(2));
             0 0 1];
    Fu_jk = [cos(EKF.B.q_est(3))*Vehicles.B.R/2, cos(EKF.B.q_est(3))*Vehicles.B.R/2;
             sin(EKF.B.q_est(3))*Vehicles.B.R/2, sin(EKF.B.q_est(3))*Vehicles.B.R/2;
             Vehicles.B.R/Vehicles.B.L, -Vehicles.B.R/Vehicles.B.L];
     
    % Algorithm to update - i is the index for A, j is the index for B
    q_est_i_k1 = EKF.A.q_est + Fu_ik*EKF.A.DeltaEnc;
    P_ii_k1 = Fx_ik*EKF.A.P*Fx_ik' + Fu_ik*EKF.A.Q*Fu_ik';
    
    q_est_j_k1 = EKF.B.q_est + Fu_jk*EKF.B.DeltaEnc;
    P_jj_k1 = Fx_jk*EKF.B.P*Fx_jk' + Fu_jk*EKF.B.Q*Fu_jk';
    
    P_ij_k1 = Fx_ik*EKF.AB.P*Fx_jk';
    P_ji_k1 = Fx_jk*EKF.AB.P*Fx_ik';

    %% Exteroceptive data integration
    % Relation between the measure and the states (Jacobian) for the GPS
    H_i = diag([1, 1, 1]);  % Complete positioning informations
    H_j = diag([1, 1, 0]);
    
    % Measurements
    a = Sensor.A.GPS.Noisyq_m(i,:);
    b = Sensor.B.GPS.Noisyq_m(i,:);
    
    % Kalman Gain
    K_i = P_ii_k1*H_i'*inv(H_i*P_ii_k1*H_i' + EKF.A.R);
    K_j = P_jj_k1*H_j'*inv(H_j*P_jj_k1*H_j' + EKF.B.R);
    
    % Algorithm to update
    q_est_i_k1 = q_est_i_k1 + K_i*(a' - H_i*q_est_i_k1);
    q_est_j_k1 = q_est_j_k1 + K_j*(b' - H_j*q_est_j_k1);
    
    P_ii_k1 = (eye(3) - K_i*H_i)*P_ii_k1;
    P_jj_k1 = (eye(3) - K_j*H_j)*P_jj_k1;
    
    %% Relative data integration
    % Linear variations
    EKF.AB.DeltaX = q_est_j_k1(1) - q_est_i_k1(1);
    EKF.AB.DeltaY = q_est_j_k1(2) - q_est_i_k1(2);
    
    % Relative orientations
    EKF.AB.DeltaTheta = q_est_j_k1(3) - q_est_i_k1(3);
    
    % Relative oservations
    z_b = atan2( -sin(q_est_i_k1(3))*EKF.AB.DeltaX + cos(q_est_i_k1(3))*EKF.AB.DeltaY , cos(q_est_i_k1(3))*EKF.AB.DeltaX + sin(q_est_i_k1(3))*EKF.AB.DeltaY);
    z_d = sqrt( EKF.AB.DeltaX^2 + EKF.AB.DeltaY^2 );
    z_o = EKF.AB.DeltaTheta;
    
    % Jacobian matrices of relative observations
    % 1 - Bearing angle
    H_i_b = [ EKF.AB.DeltaY / (EKF.AB.DeltaX^2 + EKF.AB.DeltaY^2), -EKF.AB.DeltaX / (EKF.AB.DeltaX^2 + EKF.AB.DeltaY^2), -1];
    H_j_b = [ -EKF.AB.DeltaY / (EKF.AB.DeltaX^2 + EKF.AB.DeltaY^2), EKF.AB.DeltaX / (EKF.AB.DeltaX^2 + EKF.AB.DeltaY^2),  0];
    
    % 2 - Relative distance
    H_i_d = [ -EKF.AB.DeltaX / sqrt(EKF.AB.DeltaX^2 + EKF.AB.DeltaY^2), -EKF.AB.DeltaY / sqrt(EKF.AB.DeltaX^2 + EKF.AB.DeltaY^2), 0];      
    H_j_d = [ EKF.AB.DeltaX / sqrt(EKF.AB.DeltaX^2 + EKF.AB.DeltaY^2),   EKF.AB.DeltaY / sqrt(EKF.AB.DeltaX^2 + EKF.AB.DeltaY^2), 0];
          
    % 3 - Relative orientation
    H_i_o = [0, 0, -1];
    H_j_o = [0, 0, 1];
    
    % Jacobian matrices to use in the algorithm?
    H_i_rel = [H_i_b; H_i_d; H_i_o];
    H_j_rel = [H_j_b; H_j_d; H_j_o];
    
    % Covariance matrix of the innovation for the bearing angle
    P_zz = H_i_rel*P_ii_k1*H_i_rel' + H_i_rel*P_ij_k1*H_j_rel' + H_j_rel*P_ij_k1*H_i_rel' + H_j_rel*P_jj_k1*H_j_rel' + Noise.Rel.R;
    
    % Algorithm to update - bearing angle (is H_i_b*q_est_i_k1 the
    % innovation for the i-th vehicle?)
    P_ij_k1 = P_ij_k1 - (P_ii_k1*H_i_rel'+P_ij_k1*H_j_rel')*inv(P_zz)*(H_i_rel*P_ij_k1+H_j_rel*P_jj_k1);
    P_ji_k1 = P_ji_k1 - (P_ji_k1*H_i_rel'+P_jj_k1*H_j_rel')*inv(P_zz)*(H_i_rel*P_ii_k1+H_j_rel*P_ji_k1);
    
    q_est_i_k1 = q_est_i_k1 + (P_ii_k1*H_i_rel'+P_ij_k1*H_j_rel')*inv(P_zz)*(Sensor.AB.Noisyq_rel(i,:)' - H_i_rel*q_est_i_k1);
    P_ii_k1 = P_ii_k1 - (P_ii_k1*H_i_rel'+P_ij_k1*H_j_rel')*inv(P_zz)*(H_i_rel*P_ii_k1+H_j_rel*P_ji_k1);
    
    q_est_j_k1 = q_est_j_k1 + (P_ji_k1*H_i_rel'+P_jj_k1*H_j_rel')*inv(P_zz)*(Sensor.AB.Noisyq_rel(i,:)' - H_j_rel*q_est_j_k1);
    P_jj_k1 = P_jj_k1 - (P_ji_k1*H_i_rel'+P_jj_k1*H_j_rel')*inv(P_zz)*(H_i_rel*P_ij_k1+H_j_rel*P_jj_k1);
    
    %% Storing estimated values
    EKF.A.q_store(:,i) = q_est_i_k1;
    EKF.B.q_store(:,i) = q_est_j_k1;
end

%% Plotting
t = Vehicles.A.t;
figure(1)
plot(EKF.A.q_store(1,:), EKF.A.q_store(2,:), Vehicles.A.q(:,1), Vehicles.A.q(:,2))
axis equal
figure(2)
plot(EKF.B.q_store(1,:), EKF.B.q_store(2,:), Vehicles.B.q(:,1), Vehicles.B.q(:,2))
axis equal